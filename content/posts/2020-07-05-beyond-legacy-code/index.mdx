---
title: レガシーコードからの脱却 - Beyond Legacy Code
author: Kenya Hondoh
date: 2020-07-05
hero: ./images/cypress.png
excerpt: 読中メモ
---

# 概要
- 『レガシーコードからの脱却』（オライリー社, 2019）のメモです。

# 本書の対象者
開発者，運用者，PM，PdM，ソフトウェアの利害関係者（非開発者）

# 本書の目的

- ソフトウェア開発には「レガシーコード」を作らないためのいろんなプラクティスがある。それらを状況に応じて
適切に適用できる人を増やしたいと言うのが著者の思いであり，本書の目的である。
- レガシーコードの定義　👉「修正や拡張，作業が難しいコード」のこと。
- 本書は開発者・非開発者のコミュニケーションギャップをなくし，ソフトウェア開発に関する共通認識を
築けるようにデザインされている。
- プラクティスは，XP，スクラム，リーンなどの開発手法から導かれている。

# 全体の構成

以下の2つの部から構成される：

- *第1部　レガシーコード危機*

  レガシーコードがなぜやばいのか，それによって我々がどれほどの損失を被っているのかという事実をつきつける。

- *第2部　ソフトウェアの寿命を延ばし価値を高める9つのプラクティス*

  「第1部」で提示した問題への解決策（9つのプラクティス）を提示する。一応プラクティスについて説明はするが，
  必ず読者自身でなぜそれが有効なのか説明できるようにすること。そうでなければ，実際に適用してもうまくいかない。

# 第1部　レガシーコード危機
## 1章　何かが間違っている

### 筆者の武勇伝

著者がかつてコンサルタントとして担当した組織

- コードモンキーが存在(アーキテクチャや設計を考えず，ただ仕様通りにコードを書く人)
- 開発チームの大勢が，技術プラクティスの背後にある理由を理解していない
- 作られたソフトウェアは良い標準から乖離
- チームが違えばチームごとの標準
- でも開発の中心人物・マネージャーは優秀
- 開発・QA（品質保証）・運用の対立主義

この結果，

- 「変更を加えづらいコード」
- 「変更を行うことのコミュニケーションコストが大きい」
- 「変更を加えるのにものすごい時間がかかる」

という状況になり，*みんなやる気がなくなっていった*（死のスパイラル）。

筆者は，マネージャーらと協力して，業務の20％を上記の現状を改善する活動に充てるようにした。
すると，アジリティの高いソフトウェアを作れる組織に変化させることができた。しかも，これには再現性があり
何回も同じような経験をしたらしい（武勇伝）。

>余談。筆者は「自動ユニットテストのないコードはレガシーコードである」と言う。

### 「ウォーターフォールモデル」

ウォーターフォールモデルは，以下のような状況には適している。例は自分で考えてみた。
- *まとめてリリースするのが適切なモノ*
  - iPhone：部品の性能やサイズの組み合わせを高度に最適化する必要がある。人々を飽きさせないため，
    年オーダーの周期で新製品を発表する。
  - 自動車：大量生産のために大規模な製造ラインが必要

- *リリースするものや，ビジネス状況がある程度予測可能であるモノ*
  - 橋や道路などの社会インフラ：長期的にニーズがあり，安定してそこにあって欲しい
  - 個人住宅の設計：新しい部屋を追加したいと思うことはめったにない

しかし，ソフトウェアを取り巻く環境は，上記に当てはまるだろうか？
- *ソフトウェアはまとめてリリースすべき？*
  - 今やほとんどのソフトウェアはインターネットの接続を前提に利用されるので，新しいバージョンを逐次配布できる。
  （iPhone で同じことをやろうとすると，個人宅に iPhone 分解マニュアルと部品を郵送して行うことになるけれども）
  - ソフトウェアは「大量生産」する必要がない。一度作れば同じものを容易に「複製」できる。

- *リリースするものや，ビジネス状況は予測可能？*
  - 顧客の刻々と変化するニーズに，素早くサービスを適合させなければ競争上の優位を保てない時代になった。
    そしてこの変化を予測することは困難である。
  - ソフトウェアには日々脆弱性が見つかったりバグが見つかるので，対応していく必要があるが，
  どこにこれが発現するかというのは予想できない。

### 一か八かの勝負

ソフトウェア業界におけるウォーターフォールモデルは，いろんな点で「大博打」である。

- 複数の機能が「統合」されるまで，それらの各機能にバグがあるかどうかわからない。
  コーディングしてしばらく時間が経ってようやく最初のバグに気づくことができる。
  小さく作ってすぐに検証できていれば早い段階で気づけたのに。
- プロダクトをじっくり時間をかけてリリースしても，もしそれを顧客がそれに「No」を突き付ければこれまでの開発は
無に帰する。例えば，これを避けるために『リーン・スタートアップ』では，MVP をベースに「構築・検証・学習」を高速に
繰り返し，早期に顧客からのフィードバックを得る。

>ソフトウェアを作るのに，こんなにリスキーで間違いやすい方法はほかに想像できない

### ウォーターフォールはなぜ機能しないか

- *「刺激」と「反応」が遠い*

  開発・運用・QA は縦割りで分離していることが多く，コミュニケーションコストを減らすために，タスクを一度にまとめる。
  これはチームを縦割りにして，プロセスを厳密に分けることで構造的に発生すると私は考える。

  余談：de:code 2020 の GitOps に関するセッションで，「GitOps 導入により，開発者にプロダクションのオーナーシップ
  を移譲することができるようになった。これにより，開発者のプロダクトに対する当事者意識が高まった」という話が
  あり，これに通ずるものを感じた。

- *バッチサイズが大きすぎる*

  まとめてデカいものをリリースするようにすると，それに最適化した結果，おのずと拡張性を考慮しないコードがかかれるようになる。
  しかし，ソフトウェアの特性上，現実にはコードには変更が伴う。もし，バッチサイズを小さくして，継続的に統合・デプロイ
  するようにしておけば，保守性の高いコードがかかれるようになるだろう。

### プロセスを重視して目的を見失わない

著者は，過去の体験から，プロセスを重視することを批判している。例えば，IBM では過去に「ソースコードの全ての行に
プログラマーのコメントを入れること」という規則があったそうだ。
大事なのはプロセスではなく，本来の目的を達成することである。

### ウォーターフォールの功罪

コーディングよりも最新のドキュメントの維持に膨大な労力が割かれることがある。

ソフトウェア開発はリスクが高く，ドキュメントもコードも書いた瞬間から時代遅れになる。
ウォーターフォールのプロセスがよくないのは，初期の設計フェーズが終わったらもう事実上コードを変更するのは
不可能なので，変更を避けるようになってしまうこと。

そしてテストも「高価」なので一度で成功させるために最後まで待つ。

こうして，痛みや困難を意図的に避けることが良い戦略ということになり，文化も保守的になる。

### ソフトウェア開発に銀の弾丸はない
ソフトウェア開発において，最善の選択を下すための道標はなく，状況に応じていく通りもの解があり，厳密にその効果を
見積もることはできない。やってみてはじめてわかるものばかり。

### 本章の振り返り
- ウォーターフォールは，変更が起こらないことを仮定しているが，現実にそんなことはなく，
いざ修正を加えようとするとその追跡と変更コストは高くつく。
- 機能をまとめてリリースするのは，逆説的なことに，非効率である。
- ウォーターフォールはレガシーコードの温床になる
- ソフトウェア工学には，現実の問題にうまく対処できるような基本原則や共通の知識体系が確立されていない。

## 第2章　CHAOSレポート再考

### CHAOS レポート

スタンディッシュグループの CHAOS レポートという，US 最大規模のソフトウェア開発に関するレポートがある。
ここでは，ソフトウェア開発のプロジェクトを「成功」「失敗」「問題あり」の3つにカテゴライズしており，その年次推移を報告している。
この結果によると，1994年には「成功」したプロジェクトは全体の16％にすぎなかったが，2012年には39％にまで増えている。
これは業界の成熟とアジャイルの普及によるものだと考えられるが，依然として，6割のプロジェクトは何らかの問題を抱えている。

### なぜプロジェクトは失敗するのか。

プロジェクトが失敗する要因には，ビジネスの優先度の変化や市場ニーズの変化など，外部要因によるものもあるが，ここでは
技術的な側面についてみていく。筆者は以下のようなもの，プロジェクトを失敗させる技術的要因としてを挙げる：

- コードの変更
- バグの修正
- 複雑さの扱い

### コードの変更

一般に，コードの変更それ自体の時間よりも，既存の設計・コードを読んで理解するのに時間がかかる。
そのため，変更が大規模な場合は，全体を理解するのではなく，自分たちの方法で要求された機能を継ぎ足してしまおうとするケースが増える。
その結果，システム全体をテストするのが困難になり，品質は低下し，以降の拡張も難しくなる。

既存のソフトウェアに機能を追加するコストは桁外れに高い。というのは，世のほとんどのソフトウェアは
機能拡張をうまく扱えるように設計されておらず，ひとたび機能を追加するならば全体の再設計が必要になるためだ。
このようなハイリスクで高価なソースコードをいじりたくないので，既存のコードをいじらず新しくコードを追加し，継ぎはぎのシステムができる。

開発者は，素朴にコードを書くことで変更ができないコードを生み出していることに気づくべきだ。

### バグ

バグの修正自体は些細ですぐ終わることもあるが，それを見つけ出すのには決まって長い時間がかかる。
MacOSX は 8500万行のソースコードから成る。我々は，バグが見つかりやすいように心がけるべきだ。
また，バグを書くのを防げればもっとよい。

### コードの複雑性

2002年，NIST によれば

> ソフトウェアの複雑さは増大し続ける。（略）ソフトウェア開発者はすでにほぼ 80％ の開発コストを障害の特定と障害のために使っている。
> これを以てしても，ソフトウェアほど不具合が多い状態で出荷されている製品はほぼない。

つまり，我々が価値を生み出している時間は開発時間の 20％ しかない。

ほとんどのソフトウェアは，読みやすさよりも書きやすさを優先している。こうして書かれたコードには依存性が埋め込まれ，
ある部分が別の部分に依存し ... を繰り返して，依存性は追跡できなくなる。これが，メンテナンスコストが 80％ にも膨れ上がる原因となる。

### 使われないコード

CHAOS レポートによると，デプロイされた機能の 45％ は使われないということがわかった。
つまり，我々はコストをかけて無駄を作り込んでいることになる。

ウォーターフォールでは，ソースコードが後から追加されることは無いか，極めて少ないという前提がある。
そのため，1回の貴重なリリースのタイミングで「今を逃すまい」とたくさんの機能がブチ込まれる。

リーンやアジャイルの考え方を使えば，小さく作ってすぐ顧客に使ってもらえるのですぐにフィードバックが得られる。
これにより，無駄を作り込むリスクを回避できる。

### コスト

少し古いが，[2001年の研究(G.Robert, 2001)](http://dl.acm.org/citation.cfm?id=626281)
によるとソフトウェア開発にかかるコストは以下のようになっている：

| 工程 | 割合 |
|-- |-- |
|開発|20%|
|バグ|11％|
|拡張|38%|
|その他|31%|

見ての通り，リリース後のコストはかなり高額である。
これは，ウォーターフォールが「変更を前提としないので，保守性を考慮していない」からである。

しかし，実際には表を見てわかるように，ソフトウェアには拡張やバグに伴う修正が入る。
保守性の高いコードを書こう！

### 本章の振り返り

- ソフトウェア開発の失敗による損失は，低く見積もっても年間100億ドル（US のみ）にのぼる。
- ソフトウェア開発の非効率なやり方はビジネスに多大な損失をもたらしてきた。我々はこの改善に取り組むべきだ。
- CHAOS レポートで指摘されるように，この課題を乗り越えるための道のりは遠い。
- 私たちの誰もがレガシーコードを作りうる。

このようにソフトウェア開発はめちゃくちゃリスクが高い。それでも，成功しているプロジェクトはあり，
彼らは別のアプローチをとっている。次章以降では，そのプラクティスをみていく。

## 第3章

2000年の終わり頃，成功を収めたソフトウェア開発者は，「余計なもの」に気づいていた。
そしてソフトウェア開発に適した，「軽量な」開発手法の体系が生まれようとしていた。

そこで，「軽量ソフトウェア開発プロセス」とかいうと真面目に受け止められないだろうと考え，
「アジャイルソフトウェア開発プロセス」という命名がなされた。
アジャイルの背後には，XP（エクストリーミングプログラミング），リーンなどの概念がある。

これらの先人の取り組みは，「レガシー」との闘いの始まりだった。

### アジャイル

アジャイルマニフェストには，

> 私たちは，ソフトウェア開発の実践あるいは実戦を手助けする活動を通じて，よりよい開発方法を見つけ出そうとしている。

とある。これを筆者なりに言うと，以下の考え方が根底にあるらしい：

- 顧客満足を最優先し，価値のあるソフトウェアを早く提供する
- プロセスを増やすよりも，よりプロセスを少なくし，開発者が集中してエンジニアリングプラクティスを適用できるようにする

このエンジニアリングプラクティスというのは，XP における TDD や ペアプログラミングである。
これらを取り入れ，デプロイ，運用，拡張が簡単で変更可能なソフトウェアを作れるようになるという信念があったらしい。
そして実際こっちの方が効果があったらしい。

### 小さいほど良い

長距離マラソンランナーは，「近めのゴール」を設定して走っていると言われる。「あの街灯までいくぞ！」と思えば，
42.195km に比べればなんとかなりそう，簡単そうだと思える。例えばスクラムでは，1スプリントで
*「大きなタスクを，目に見える成果を作り出す単位に落とし込む」*。これにより，*タスクの見積もり，実装，検証* が容易になる。

そして，このタスクのライフサイクルがすぐに終わるほど良く，作業に取り掛かって進展が無い状態（顧客に提供していない＝無駄な状態）
を短くした方が良い。

### やり方ではなく，目的と理由

アジャイルでは，仕様書ではなく，プロダクトオーナーと開発者の会話を重視する。
*ユーザーストーリー* という概念が登場するのは，これを会話のきっかけにするためである。
そして，プロダクトオーナーはユーザーストーリーをもとに顧客と会話する。
ここで顧客の要求から詳細な仕様を聞き出して，その先も仕様書を維持管理しているとすれば，それは
プロダクトオーナー付きのウォーターフォールに他ならない。

### 本章の振り返り
TODO: 書く

>多くのアジャイルチームは技術プラクティスを認識していないか，適用の仕方が間違っているために，期待した利益を得られないでいる。
>プラクティスを適切に適用するには，その背後にある現ｓｸを理解しなければいけないのだ。

# 第２部　ソフトウェアの寿命を延ばし価値を高める9つのプラクティス

すげー開発者は，普通の人がやらないちょっとしたことを普段から心がけることで優れた開発者となっていて，その技能は学習可能である。
我々も，彼らが身につけた原則やプラクティスを理解して実践しよう。

## 第4章　9つのプラクティス

