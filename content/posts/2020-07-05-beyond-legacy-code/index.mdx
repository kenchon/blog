---
title: レガシーコードからの脱却 - Beyond Legacy Code
author: Kenya Hondoh
date: 2020-07-05
hero: ./images/legacy.jpg
excerpt: 読中メモ
---

# 概要
- 『レガシーコードからの脱却』（オライリー社, 2019）のメモです。

### 本書の対象者

開発者，運用者，PM，PdM，ソフトウェアの利害関係者（非開発者）

### 本書の目的

- ソフトウェア開発には「レガシーコード」を作らないためのいろんなプラクティスがある。それらを状況に応じて
適切に適用できる人を増やしたいと言うのが著者の思いであり，本書の目的である。
- レガシーコードの定義　👉「修正や拡張，作業が難しいコード」のこと。
- 本書は開発者・非開発者のコミュニケーションギャップをなくし，ソフトウェア開発に関する共通認識を
築けるようにデザインされている。
- プラクティスは，XP，スクラム，リーンなどの開発手法から導かれている。

### 全体の構成

以下の2つの部から構成される：

- *第1部　レガシーコード危機*

  レガシーコードがなぜやばいのか，それによって我々がどれほどの損失を被っているのかという事実をつきつける。

- *第2部　ソフトウェアの寿命を延ばし価値を高める9つのプラクティス*

  「第1部」で提示した問題への解決策（9つのプラクティス）を提示する。一応プラクティスについて説明はするが，
  必ず読者自身でなぜそれが有効なのか説明できるようにすること。そうでなければ，実際に適用してもうまくいかない。

# 第1部　レガシーコード危機
## 1章　何かが間違っている

#### 筆者の武勇伝

著者がかつてコンサルタントとして担当した組織

- コードモンキーが存在(アーキテクチャや設計を考えず，ただ仕様通りにコードを書く人)
- 開発チームの大勢が，技術プラクティスの背後にある理由を理解していない
- 作られたソフトウェアは良い標準から乖離
- チームが違えばチームごとの標準
- でも開発の中心人物・マネージャーは優秀
- 開発・QA（品質保証）・運用の対立主義

この結果，

- 「変更を加えづらいコード」
- 「変更を行うことのコミュニケーションコストが大きい」
- 「変更を加えるのにものすごい時間がかかる」

という状況になり，*みんなやる気がなくなっていった*（死のスパイラル）。

筆者は，マネージャーらと協力して，業務の20％を上記の現状を改善する活動に充てるようにした。
すると，アジリティの高いソフトウェアを作れる組織に変化させることができた。しかも，これには再現性があり
何回も同じような経験をしたらしい（武勇伝）。

>余談。筆者は「自動ユニットテストのないコードはレガシーコードである」と言う。

#### 「ウォーターフォールモデル」

ウォーターフォールモデルは，以下のような状況には適している。例は自分で考えてみた。
- *まとめてリリースするのが適切なモノ*
  - iPhone：部品の性能やサイズの組み合わせを高度に最適化する必要がある。人々を飽きさせないため，
    年オーダーの周期で新製品を発表する。
  - 自動車：大量生産のために大規模な製造ラインが必要

- *リリースするものや，ビジネス状況がある程度予測可能であるモノ*
  - 橋や道路などの社会インフラ：長期的にニーズがあり，安定してそこにあって欲しい
  - 個人住宅の設計：新しい部屋を追加したいと思うことはめったにない

しかし，ソフトウェアを取り巻く環境は，上記に当てはまるだろうか？
- *ソフトウェアはまとめてリリースすべき？*
  - 今やほとんどのソフトウェアはインターネットの接続を前提に利用されるので，新しいバージョンを逐次配布できる。
  （iPhone で同じことをやろうとすると，個人宅に iPhone 分解マニュアルと部品を郵送して行うことになるけれども）
  - ソフトウェアは「大量生産」する必要がない。一度作れば同じものを容易に「複製」できる。

- *リリースするものや，ビジネス状況は予測可能？*
  - 顧客の刻々と変化するニーズに，素早くサービスを適合させなければ競争上の優位を保てない時代になった。
    そしてこの変化を予測することは困難である。
  - ソフトウェアには日々脆弱性が見つかったりバグが見つかるので，対応していく必要があるが，
  どこにこれが発現するかというのは予想できない。

#### 一か八かの勝負

ソフトウェア業界におけるウォーターフォールモデルは，いろんな点で「大博打」である。

- 複数の機能が「統合」されるまで，それらの各機能にバグがあるかどうかわからない。
  コーディングしてしばらく時間が経ってようやく最初のバグに気づくことができる。
  小さく作ってすぐに検証できていれば早い段階で気づけたのに。
- プロダクトをじっくり時間をかけてリリースしても，もしそれを顧客がそれに「No」を突き付ければこれまでの開発は
無に帰する。例えば，これを避けるために『リーン・スタートアップ』では，MVP をベースに「構築・検証・学習」を高速に
繰り返し，早期に顧客からのフィードバックを得る。

>ソフトウェアを作るのに，こんなにリスキーで間違いやすい方法はほかに想像できない

#### ウォーターフォールはなぜ機能しないか

- *「刺激」と「反応」が遠い*

  開発・運用・QA は縦割りで分離していることが多く，コミュニケーションコストを減らすために，タスクを一度にまとめる。
  これはチームを縦割りにして，プロセスを厳密に分けることで構造的に発生すると私は考える。

  余談：de:code 2020 の GitOps に関するセッションで，「GitOps 導入により，開発者にプロダクションのオーナーシップ
  を移譲することができるようになった。これにより，開発者のプロダクトに対する当事者意識が高まった」という話が
  あり，これに通ずるものを感じた。

- *バッチサイズが大きすぎる*

  まとめてデカいものをリリースするようにすると，それに最適化した結果，おのずと拡張性を考慮しないコードがかかれるようになる。
  しかし，ソフトウェアの特性上，現実にはコードには変更が伴う。もし，バッチサイズを小さくして，継続的に統合・デプロイ
  するようにしておけば，保守性の高いコードがかかれるようになるだろう。

#### プロセスを重視して目的を見失わない

著者は，過去の体験から，プロセスを重視することを批判している。例えば，IBM では過去に「ソースコードの全ての行に
プログラマーのコメントを入れること」という規則があったそうだ。
大事なのはプロセスではなく，本来の目的を達成することである。

#### ウォーターフォールの功罪

コーディングよりも最新のドキュメントの維持に膨大な労力が割かれることがある。

ソフトウェア開発はリスクが高く，ドキュメントもコードも書いた瞬間から時代遅れになる。
ウォーターフォールのプロセスがよくないのは，初期の設計フェーズが終わったらもう事実上コードを変更するのは
不可能なので，変更を避けるようになってしまうこと。

そしてテストも「高価」なので一度で成功させるために最後まで待つ。

こうして，痛みや困難を意図的に避けることが良い戦略ということになり，文化も保守的になる。

#### ソフトウェア開発に銀の弾丸はない
ソフトウェア開発において，最善の選択を下すための道標はなく，状況に応じていく通りもの解があり，厳密にその効果を
見積もることはできない。やってみてはじめてわかるものばかり。

#### 本章の振り返り
- ウォーターフォールは，変更が起こらないことを仮定しているが，現実にそんなことはなく，
いざ修正を加えようとするとその追跡と変更コストは高くつく。
- 機能をまとめてリリースするのは，逆説的なことに，非効率である。
- ウォーターフォールはレガシーコードの温床になる
- ソフトウェア工学には，現実の問題にうまく対処できるような基本原則や共通の知識体系が確立されていない。

## 第2章　CHAOSレポート再考

#### CHAOS レポート

スタンディッシュグループの CHAOS レポートという，US 最大規模のソフトウェア開発に関するレポートがある。
ここでは，ソフトウェア開発のプロジェクトを「成功」「失敗」「問題あり」の3つにカテゴライズしており，その年次推移を報告している。
この結果によると，1994年には「成功」したプロジェクトは全体の16％にすぎなかったが，2012年には39％にまで増えている。
これは業界の成熟とアジャイルの普及によるものだと考えられるが，依然として，6割のプロジェクトは何らかの問題を抱えている。

#### なぜプロジェクトは失敗するのか。

プロジェクトが失敗する要因には，ビジネスの優先度の変化や市場ニーズの変化など，外部要因によるものもあるが，ここでは
技術的な側面についてみていく。筆者は以下のようなもの，プロジェクトを失敗させる技術的要因としてを挙げる：

- コードの変更
- バグの修正
- 複雑さの扱い

#### コードの変更

一般に，コードの変更それ自体の時間よりも，既存の設計・コードを読んで理解するのに時間がかかる。
そのため，変更が大規模な場合は，全体を理解するのではなく，自分たちの方法で要求された機能を継ぎ足してしまおうとするケースが増える。
その結果，システム全体をテストするのが困難になり，品質は低下し，以降の拡張も難しくなる。

既存のソフトウェアに機能を追加するコストは桁外れに高い。というのは，世のほとんどのソフトウェアは
機能拡張をうまく扱えるように設計されておらず，ひとたび機能を追加するならば全体の再設計が必要になるためだ。
このようなハイリスクで高価なソースコードをいじりたくないので，既存のコードをいじらず新しくコードを追加し，継ぎはぎのシステムができる。

開発者は，素朴にコードを書くことで変更ができないコードを生み出していることに気づくべきだ。

#### バグ

バグの修正自体は些細ですぐ終わることもあるが，それを見つけ出すのには決まって長い時間がかかる。
MacOSX は 8500万行のソースコードから成る。我々は，バグが見つかりやすいように心がけるべきだ。
また，バグを書くのを防げればもっとよい。

#### コードの複雑性

2002年，NIST によれば

> ソフトウェアの複雑さは増大し続ける。（略）ソフトウェア開発者はすでにほぼ 80％ の開発コストを障害の特定と障害のために使っている。
> これを以てしても，ソフトウェアほど不具合が多い状態で出荷されている製品はほぼない。

つまり，我々が価値を生み出している時間は開発時間の 20％ しかない。

ほとんどのソフトウェアは，読みやすさよりも書きやすさを優先している。こうして書かれたコードには依存性が埋め込まれ，
ある部分が別の部分に依存し ... を繰り返して，依存性は追跡できなくなる。これが，メンテナンスコストが 80％ にも膨れ上がる原因となる。

#### 使われないコード

CHAOS レポートによると，デプロイされた機能の 45％ は使われないということがわかった。
つまり，我々はコストをかけて無駄を作り込んでいることになる。

ウォーターフォールでは，ソースコードが後から追加されることは無いか，極めて少ないという前提がある。
そのため，1回の貴重なリリースのタイミングで「今を逃すまい」とたくさんの機能がブチ込まれる。

リーンやアジャイルの考え方を使えば，小さく作ってすぐ顧客に使ってもらえるのですぐにフィードバックが得られる。
これにより，無駄を作り込むリスクを回避できる。

#### コスト

少し古いが，[2001年の研究(G.Robert, 2001)](http://dl.acm.org/citation.cfm?id=626281)
によるとソフトウェア開発にかかるコストは以下のようになっている：

| 工程 | 割合 |
|-- |-- |
|開発|20%|
|バグ|11％|
|拡張|38%|
|その他|31%|

見ての通り，リリース後のコストはかなり高額である。
これは，ウォーターフォールが「変更を前提としないので，保守性を考慮していない」からである。

しかし，実際には表を見てわかるように，ソフトウェアには拡張やバグに伴う修正が入る。
保守性の高いコードを書こう！

#### 本章の振り返り

- ソフトウェア開発の失敗による損失は，低く見積もっても年間100億ドル（US のみ）にのぼる。
- ソフトウェア開発の非効率なやり方はビジネスに多大な損失をもたらしてきた。我々はこの改善に取り組むべきだ。
- CHAOS レポートで指摘されるように，この課題を乗り越えるための道のりは遠い。
- 私たちの誰もがレガシーコードを作りうる。

このようにソフトウェア開発はめちゃくちゃリスクが高い。それでも，成功しているプロジェクトはあり，
彼らは別のアプローチをとっている。次章以降では，そのプラクティスをみていく。

## 第3章

2000年の終わり頃，成功を収めたソフトウェア開発者は，「余計なもの」に気づいていた。
そしてソフトウェア開発に適した，「軽量な」開発手法の体系が生まれようとしていた。

そこで，「軽量ソフトウェア開発プロセス」とかいうと真面目に受け止められないだろうと考え，
「アジャイルソフトウェア開発プロセス」という命名がなされた。
アジャイルの背後には，XP（エクストリーミングプログラミング），リーンなどの概念がある。

これらの先人の取り組みは，「レガシー」との闘いの始まりだった。

#### アジャイル

アジャイルマニフェストには，

> 私たちは，ソフトウェア開発の実践あるいは実戦を手助けする活動を通じて，よりよい開発方法を見つけ出そうとしている。

とある。これを筆者なりに言うと，以下の考え方が根底にあるらしい：

- 顧客満足を最優先し，価値のあるソフトウェアを早く提供する
- プロセスを増やすよりも，よりプロセスを少なくし，開発者が集中してエンジニアリングプラクティスを適用できるようにする

このエンジニアリングプラクティスというのは，XP における TDD や ペアプログラミングである。
これらを取り入れ，デプロイ，運用，拡張が簡単で変更可能なソフトウェアを作れるようになるという信念があったらしい。
そして実際こっちの方が効果があったらしい。

#### 小さいほど良い

長距離マラソンランナーは，「近めのゴール」を設定して走っていると言われる。「あの街灯までいくぞ！」と思えば，
42.195km に比べればなんとかなりそう，簡単そうだと思える。例えばスクラムでは，1スプリントで
*「大きなタスクを，目に見える成果を作り出す単位に落とし込む」*。これにより，*タスクの見積もり，実装，検証* が容易になる。

そして，このタスクのライフサイクルがすぐに終わるほど良く，作業に取り掛かって進展が無い状態（顧客に提供していない＝無駄な状態）
を短くした方が良い。

#### やり方ではなく，目的と理由

アジャイルでは，仕様書ではなく，プロダクトオーナーと開発者の会話を重視する。
*ユーザーストーリー* という概念が登場するのは，これを会話のきっかけにするためである。
そして，プロダクトオーナーはユーザーストーリーをもとに顧客と会話する。
ここで顧客の要求から詳細な仕様を聞き出して，その先も仕様書を維持管理しているとすれば，それは
プロダクトオーナー付きのウォーターフォールに他ならない。

#### 本章の振り返り
TODO: 書く

>多くのアジャイルチームは技術プラクティスを認識していないか，適用の仕方が間違っているために，期待した利益を得られないでいる。
>プラクティスを適切に適用するには，その背後にある原則を理解しなければいけないのだ。

# 第２部　ソフトウェアの寿命を延ばし価値を高める9つのプラクティス

すげー開発者は，普通の人がやらないちょっとしたことを普段から心がけることで優れた開発者となっていて，その技能は学習可能である。
我々も，彼らが身につけた原則やプラクティスを理解して実践しよう。

## 第4章　9つのプラクティス

プラクティスの背後には原理がある。ソフトウェア開発では，この原理が次第に確立されようとしている。

その例として，

- *単一責務の原則* 
「クラスを変更する理由は一つでなければいけない」
　
- *開放・閉鎖の原則*
　「ソフトウェアのエンティティ（クラス・関数・モジュール）は拡張に対して開き，変更に対して閉じなければいけない」

がある。こうした原則（本書では2つを挙げるにとどまっているが）を実現することがソフトウェア開発の崇高なゴールであり，すべてのプラクティスが
これを実現するようなものでなければならない（つまり憲法）。

本書紹介するプラクティスは，こうしたソフトウェア開発で確立されようとしている原則を実現する9つのプラクティスを紹介するが，それらは以下の配慮されている：

- 多くの場合に価値がある
- 学ぶのが容易で，教えるのが容易である
- 実施がシンプルで，考えなくてもやれる

これらの条件を満たしていないと，プラクティスは継続しづらいものとなる。人間は怠惰なので，極力やりやすい仕組みを作る必要がある。

さて，先ほど原則の話が出たが，プラクティスはそれだけを盲目的に取り入れれば良いというものではない。きちんと原則を理解して，なぜそのプラクティスが有効なのか
ちゃんと説明できる必要がある。そうすることでより効果的に適用できるようになる。

#### 良いコード

価値のあるソフトウェアには変更が伴う。つまり，ユーザーがソフトウェアから価値を引き出す新たな方法を見つけたことを意味するからだ。
価値のあるソフトウェアは将来変更されることになる。こうした背景を踏まえると，ソースコードはどのような状態にしておくのが良いだろうか。

筆者は次のようにいう。

「既存ソフトのバグ対応・機能追加のコストを考えると，何を差し置いても，ソフトウェアは当初の機能要件を満たし将来のニーズに
対応できるように変更しやすくすべきだ。ソフトウェアを変更可能にできれば，初期開発の ROI を改善できる」

「ソフトウェアは資産であり，資産価値は現在生み出せる価値だけでなく，将来に生み出される価値にも依存する。ソフトウェア開発にも
ライフサイクルマネジメントが必要だ」

また，筆者は次のような「品質」こそ重視すべきだという。

ソースコード・ソフトウェアには，「カバレッジ」「速さ」などの外部指標が存在するが，これはブラックボックスなソフトウェアの
ある一面が数値化できたにすぎない。本書でいう「品質」は，「変更を加えやすいコードか」「わかりやすいコードか」
「リファクタリングされているか」といった *内部品質* を「品質」と読んでいる。これを作り込んだ結果，外部品質が向上する。

これは，「アジャイルをやっている」だけでは実現できない。アジャイルの背後にある原則を理解してはじめて効果的に
内部品質を向上させることができる。

#### 本章の振り返り

9つのプラクティス

# 第9章　プラクティス5　「CLEAN」コードを作る

コードの品質指標，*CLEAN* とは

  - ロバート・マーチンが『Clean Code: アジャイルソフトウェア達人の技』で提唱。
  - コードの品質の指標についてのアクロニム（頭文字）

それぞれ，

  - **Cohesive** : 凝集性
  - **Loosely Coupled** : 疎結合
  - **Encapsulated** : カプセル化
  - **Assertive** : 断定的
  - **Nonredundant** : 非冗長

簡単にいうと，オブジェクトは特定が明確に定義されていて（**凝集性**），はっきりした責務を担い（**疎結合**），実装は隠蔽されているべきだ(**カプセル化**)。
オブジェクトの状態は自分自身が管理し（**断定的**），オブジェクトの定義は一度だけにすべきだ（**非冗長**）。という原則。

### 高品質のコードは凝集性が高い

それぞれの部品は一つのものだけを扱う。それぞれのクラスが自分の責任に集中し，自分の仕事をうまくやるように設計する。
こうしておけば，何か1つの変更が必要が生じた時に，対応するクラスだけ変更すればよくなる。
変更による影響調査とテストが簡単になる。

そのようなクラスには，その責任を表す端的な命名が可能である。もし命名できないなら，色々やらせすぎている可能性がある。

### 高品質のコードは疎結合である

オブジェクト間の関係を明確な意図を持った状態に保つことを「疎結合」という。
疎結合なコードは，それを利用しているコードに対して **間接的にしか依存しない** 。よって，分離，検証，再利用，拡張が楽になる。

疎結合は通常，間接的な呼び出しによって実現される。サービスを直接呼び出すのではなく，中間層を通じて呼び出す。
これにより，サービスに変更があっても呼び出し元の変更の影響を減らすことができる。

### 高品質のコードはカプセル化されている

実装の詳細は，外部の世界からは見えなくなっている。

より厳密にいうと *カプセル化* とは，以下を切り離すことである。

- **インタフェース**（自分がやろうとしていること）
- **実装**（どうやってやるか） 

中で何やっているかを隠蔽し，入出力だけを公開するので，他のコードに影響を与えずに自由にコードを変えられるようになったり，
コードがモジュール化されるので扱いやすくなるなどのメリットがある。

#### アウトサイドインプログラミング

コンシューマの観点で機能を設計する。サービスはクライアントのニーズに基づいて設計される。
サービスが何をやっているかを示す名前をつけ，*それがどう動くかは隠す*。
これによって，サービスの高レベルの結合を意識できるようになる。

#### インサイドアウトプログラミング

問題を小さなかたまりに分解し，それらを縫い合わせて1つのソリューションを作るというもの。
実際にコーディングにいきつくまでに必要になる。ただし，全体像への配慮が欠けると責任が明確でない壊れやすいコードが生まれがち。

良いカプセル化のためには，上記の2つの視点が必要だが，やはり，高レベルの視点で眺めることが肝要。

そのコンポーネントは，**何なのか，何のためにあるのか** から始める。

こうした高レベルの視座があれば，コンピュータのバックグラウンドがないドメインエキスパートとのコミュニケーションも可能になる。
詳細を切り離しておけば，チーム全体でシステム化対象の理解がしやすくなり，コミュニケーションコストも下がるし，柔軟性，一貫性の向上に役立つ。

*ソフトウェアがどう作られているかではなく，ソフトウェアを使うことによって得られる体験から始める。*

#### カプセル化の方法

色々ある。

- 概念を抽象化して隠す
- メソッド化する
- インタフェースを導入する

ソフトウェア開発においていつでも通用する「知らぬが仏」パターンがある。依存が少なければ少ないほど，コードの変更は簡単になる。

しかし，カプセル化したものを公開する必要がある時もある。その時は，必要に応じて小出しに公開する。

とりあえずクラスのデータを `private` で宣言しておいて，必要があれば `getter`, `setter` などでアクセスできるようにする。

カプセル化を習慣化することで，呼び出し元を意識して設計するようになる。入出力が明確になり，システムの相互作用における副作用が減り，
コードを説明する明確なドキュメントにもなる。

メソッドシグネチャなどは，カプセル化の良い方法である。これは「実装ではなくインタフェースをプログラムする」というパターンである。

*必要なものだけを公開し，それ以外は隠すこと。*

### 高品質のコードは断定的である。

断定的とは？

👉 自分が何をやるコードなのか，自分の責任はどこなのかはっきりしている。

>問 🔍
>
>**`Docs` の印刷を制御するコードは， `Docs` クラスの一部にするべきか，`Printer` クラスにすべきか。** 
>
> - 一見 `Printer` クラスが良さげだが，印刷する中身は `Docs` が持つ。つまり，印刷を制御する要素の一つが 
> `Printer` 以外にあり得ることを示す。
> - `Printer` は，`Docs` が \*.pdf か \*.jpg という `Docs` 特有の事情を扱いたくない。そんな実装をしていたら，
> 新しい拡張子が追加されたときに，`Printer` まで影響を受けてしまう。

上記のような問題は，SOLID 原則の **依存性逆転の方速** ＝ 具象は抽象に依存しなければならない　とも関連する。

筆者は，他のオブジェクトとの依存性が多いオブジェクトを「好奇心旺盛なオブジェクト」という。

オブジェクトが機能するために，常に何らかのオブジェクトを参照する必要があり，いずれそれは人で追えなくなる。

これは先ほど述べた *カプセル化* の原則とも反する。

なので，オブジェクト自身で状態を管理できる方が良い。

こうした問題はなかなかわかりづらいので，普段から適切な場所に移すようにした方が良い。

### 高品質なコードは冗長でない

ミッションクリティカルなアプリケーションは冗長でも良い。人の命がかかっているから。そしてこれは，意図的な冗長である。

ここでは，*意図しない冗長* について語る。c.f. DRY原則 (Don't Repeat Yourself)

長ったらしいコードがあって，それを別の場所で使いたい時，コピペした方が良いだろうか？おそらく，関数名をつけて使いまわした方が良い。

>💡余談：『リーダブル・コード』では，`/util` （ユーティリティ用のコード置き場）を用意することを推奨している。

コードを書いた当事者なら，「ああ，これはこのパターンをコピペしたんだな」とすぐわかるが，時間が経てば一目ではわからなくなる。

ちゃんと一つの関数にまとめておけば，そんな労力は必要なかったのに〜ということになりかねない。

1つで済むもの冗長になっていると，テストもビルドも読む時間も冗長になってつらくなる。できるだけまとめて抽象化しよう。

### コード品質が私たちを導いてくれる

*CLEAN コード* の原則は，ちまちましたものかもしれない。でも，これらは，

- オブジェクトははっきりと定義された特徴を持つ
- オブジェクトは自分の責任に注力する
- オブジェクトの実装の詳細は隠されている
- オブジェクトの自身の状態は自分で管理する
- オブジェクトは一度だけ定義される

という恩恵を与えてくれる。

長ったらしいが，

- コードに*凝集性*があれば，理解もバグを見つけるのも簡単になる。それぞれのエンティティは1つのことしか扱っていないから。
- コードが*疎結合*であれば，エンティティ間の副作用が起こることも少なくなる。テスト・再利用・拡張がより簡単になる。
- コードが*カプセル化*されていれば，複雑さを管理し，呼び出し元がその先の詳細を知らなくても良いように維持できる。詳細を変更しても，呼び出し元に変更は必要ない。
- コードが*断定的*であれば，振る舞いを配置する場所が，依存データがある場所であることを示す。
- コードが*冗長でない*なら，バグ修正や変更を1箇所で1回だけやればよい。

これらの原則は，相互に独立しているわけではないので，どれかを達成すると他のも達成できるような感じになっている。
コードをチェックするときの観点として1個2個妥当そうなものについて着目すると良さそうである。

筆者が好きな原則は **Cohesive（凝集性）** だそうだ。これは簡単に見つけて直せる。コードがやっていることに名前をつけることを
手助けしてくれる。

### 明日のベロシティのために今日品質を上げる。