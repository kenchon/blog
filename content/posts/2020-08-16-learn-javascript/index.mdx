---
title: JavaScript のお勉強 with MDN docs
author: Kenya Hondoh
date: 2020-08-16
hero: ./image.png
excerpt: 俺たちは雰囲気で JavaScript を書いている。
---

### 概要
- JavaScript を雰囲気で書いていたので，[MDN Web Docs の JavaScript 入門編](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Introduction)を読むことにした。この記事はそのメモである。
- JavaScript が生まれた経緯や，構文や制御フローを Java から踏襲した話，Java との違いについても[ページの冒頭](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Introduction)に書いてあっておもしろい。


### セミコロンの扱い

- 1行1式ならセミコロン不要。
- 複数行を1行にまとめて書くなら式の区切りとして必要。
- でも，基本的につけることを推奨。

```js
// 複数の式を1行で書く時セミコロンいる
const a = 1; const b=2; const c=3;
// 1行1式ならつけなくてもOK 
console.log( a + b + c )
```

### 巻き上げ

宣言してない変数を利用したとき，普通は `ReferenceError` という例外が発生する。

でも，その変数を利用したあとで宣言する場合，利用する場所において例外が発生しない仕様になっている。
例えば，以下の例では，2行目で `あ` を宣言しているので 1行目の時点で `あ` を未宣言であっても例外を発生しない。

```js
console.log(あ === undefined);  // true となり，例外を発生しない。
var あ = "a";
console.log(あ)  // a
```

これは，以下のコードのように解釈されるかららしい。

```js
var あ;
console.log(あ === undefined);  // true となり，例外を発生しない。
var あ = "a";
console.log(あ)  // a
```

このように，コードの先頭で `undefined` の `あ` が宣言されているように見えるので，これを *巻き上げ*（ホイスティング）と呼ぶ。

なんのためにこんな仕様があるのか？[この解説](https://qiita.com/Stranger_31/items/20baef019c117c3180d9)によれば，

> ✏️ かつての JS は，関数を使う時はあらかじめ関数を宣言しておかないといけなかった。でも，関数を呼び出すコードよりも下のほうに関数宣言したいお気持ちもあったので，それができるようにした。
> その副作用として， var で宣言した変数についても「巻き上げ」が起こることになった。

だそうです。なお，`const`，`let` で後出し宣言した場合は，巻き上げは起こらず，ちゃんと例外が発生します。以下に例を示します。

```js
var あ;
console.log(あ === undefined);  // ReferenceError
const あ = "a";
console.log(あ)  // a
```

### 変数名に Unicode 文字列が使える
例）
```js
const 俺の名前 = '田中太郎';
console.log(俺の名前);
```

### `const` で宣言されたオブジェクトの挙動

`const`  で宣言されたとしても，オブジェクトの**プロパティ**は保護されません。

以下の例のように，プロパティは書き換えられます：

```js
const MY_ARRAY = ['HTML','CSS'];
MY_ARRAY.push('JAVASCRIPT');
console.log(MY_ARRAY); //logs ['HTML','CSS','JAVASCRIPT'];
```

### 数値から文字列への変換

数値を表す文字列（例：`"11"`）の先頭に `+` をつけると数値として扱われる。 
```js
const a = '11';
console.log(a + a); // 1111
console.log(+a + +a); // 22
```

おそらく JS 特有でかつ知ってたら便利そうなのでメモしておく。

### `let` と `const` のスコープ

**ECMAScript 2015 ** からは、`let` や `const` による変数宣言はブロックスコープとなる。
```js
var global = 'トップレベルのグローバル変数';
let local = 'トップレベルのローカル変数';
{
  var global = 'ブロック内で宣言したグローバル変数';
  let local = 'ブロック内で宣言したローカル変数';
}
console.log(global); // ブロック内で宣言したグローバル変数
console.log(local); // トップレベルのローカル変数
```

### `false` をとりうる値

以下の値は  `false`  と評価される (また、[Falsy](https://developer.mozilla.org/ja/docs/Glossary/Falsy)  な値と呼ばれています)。
-   `false`
-   `undefined`
-   `null`
-   `0`
-   `NaN`
-   空の文字列 (`""`)

なお，これ以外の値はすべて `true` になる。


### 例外

例外，こんな感じで書ける。

```js
 try {
	初期化していない変数 = '例外発生するぞ';
 }
 catch (err) {
	console.error('例外発生'); // console.log() よりも推奨される
 }
```

`try` ブロック では，**任意の** 型の例外を発生(`throw`)し，`catch` ブロックに渡すことができる。

### `try...catch...finally`

- `finally` ブロックは，例外が `catch` されなくても実行される。
- `finally` があることで，例外発生時にスクリプトを停止させることができる。例えば，スクリプトで使用していたリソースを解放しなければならないとき。

例)
```js
openMyFile();
try {
  writeMyFile(theData); // ここでエラーがスローされる可能性がある
} catch(e) {  
  handleError(e); // エラーを受け取り、それを処理する
} finally {
  closeMyFile(); // 常にリソースが閉じられる
}
```

### 例外でエラーキャッチするとき

`err.name`, `err.message` を使って，エラーのプロパティにアクセスする。

```js
try {
	初期化していない変数 = '例外発生するぞ';
}
catch (err) {
	console.error(err.name); // ReferenceError
	console.error(err.message); // assignment to undeclared variable 初期化していない変数
}
```

これを使ってカスタムな例外を発生させる：

```js
  function 例外発生器() {
    const 文字列型変数 = 1000;
    if (typeof(文字列型変数) == 'number') {
      throw (new Error('これは文字列型ではないよ'));
    }
  }
  
  try {
    例外発生器();
  } catch (err) {
    console.error(err.name);  // Error
    console.error(err.message);  // これは文字列型ではないよ
  }
```

### ラベル付き文

ループに対してラベルをつけることができる。

```js
  // ループに名前をつけられる
  楽しいループ:
  for (let word of ['JS楽しい！', 'JS is fun!']){
    console.log(word);
  }
```

こうすることで，入れ子になったループでどのループを `break` するか決めることができる。

例）
```js

  // 野菜を棚に詰めていく。
  // 棚が満杯になったら終了する。
  const 野菜たち = [
    {name:'にんじん', stock:3},
    {name:'たまねぎ', stock:1},
    {name:'みょうが', stock:4},
    {name:'れんこん', stock:1},
  ];

  const 棚のサイズ = 8;
  let 棚の中身 = [];
  
  野菜ループ:
  for (let 野菜 of 野菜たち) {
    // 棚に詰める野菜
    console.log(野菜.name);
    console.log(野菜.stock);
    
    棚に詰める:
    for (let i = 0; i<野菜.stock; i++) {
      棚の中身.push(野菜.name)
      if (棚の中身.length == 棚のサイズ) {
        break 野菜ループ;
      }
    }
  }
```

### `for...in` と `for...of`

- `for...in` では，プロパティ名に対してループを実行する。
- `for...of` では，プロパティの値に対してループを実行する。

```js
const arr = [3, 5, 7];
arr.foo = 'hello';

for (let i in arr) {
   console.log(i); // "0", "1", "2", "foo" が出力される
}

for (let i of arr) {
   console.log(i); // 3, 5, 7 が出力される
}
```

続く...
